package dev.practice.OpenFeign.adapter.out.web;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

import java.util.Map;

/**
 * Feign 내부 HTTP 클라이언트는 기본적으로 블로킹 I/O 모델을 사용한다.
 * 이 경우, 작업 스레드가 외부 서버로 HTTP 요청을 보낸 후 응답을 받을 때까지 블로킹 된다.
 * 이로 인해 스레드가 응답을 기다리는 동안 유휴 상태가 되어 리소스를 낭비하는 단점이 있다.
 *
 * 이 문제를 해결하기 위해 비블로킹 I/O 모델이나 비동기 I/O 모델이 사용될 수 있다.
 * 이러한 모델에서는 스레드가 응답을 기다리는 동안 다른 작업을 수행할 수 있다.
 * Spring WebFlux는 이러한 논블로킹 I/O 모델을 기반으로 한다.
 *
 * <참고>
 * 비동기는 호출 스레드가 작업의 완료를 기다리지 않고 반환하는 것을 의미한다.
 * -> 실행도 안했는데 뭘 반환하냐.. 실제로 void 일 수도 있고 Future 을 이용한다.
 * 반면, 블로킹은 작업을 수행하는 스레드가 작업의 완료를 기다리는 것을 의미한다.
 * 이 두 개념은 서로 배타적이지 않다.
 *
 * <참고>
 * @Async 를 사용하면, 해당 메서드는 별도의 작업 스레드에서 실행되기 때문에,
 * 원래의 호출 스레드는 메서드의 실행이 완료될 때까지 기다리지 않고 즉시 반환하게 된다.
 * 이런 의미에서 @Async는 '비동기' 방식이다.
 *
 * 그런데 작업 스레드에서 실행되는 @Async 메서드 내부의 로직이
 * 어떤 방식으로 동작하느냐에 따라 '블로킹' 또는 '논블로킹'이라는 개념이 적용된다.
 * 만약 메서드 내부에서 I/O 작업 등의 차단 가능한 연산을 수행하고 이 연산이 완료될 때까지 기다리면,
 * 이는 '블로킹' 방식의 동작이다.
 * 이 경우, 비록 호출 스레드는 메서드의 완료를 기다리지 않아 비동기적으로 동작하지만,
 * @Async 메서드를 실행하는 작업 스레드는 해당 작업이 완료될 때까지 차단되게 된다.
 *
 * 따라서 @Async를 사용한 메서드의 동작 방식은 비동기적이지만,
 * 메서드 내부의 작업은 블로킹일 수 있다.
 * 즉, 비동기와 블로킹은 서로 배타적인 개념이 아니라, 각각 다른 수준에서 적용되는 개념이다.
 * 비동기는 호출 스레드와 메서드 실행 스레드 간의 관계에 대한 것이며,
 * 블로킹은 메서드 내부의 특정 작업이 스레드를 차단하는지 여부에 대한 것이다.
 *
 * 따라서 @Async를 사용하여 비동기적으로 외부 API를 호출할 수 있지만,
 * 실제 I/O 작업은 여전히 블로킹 될 수 있다.
 * 이는 비동기 작업 스레드가 I/O 작업을 수행하는 동안 다른 작업을 처리할 수 없으므로,
 * 동시성이 제한되고, 리소스 사용이 비효율적일 수 있다.
 *
 * 이런 이유로, 외부 API와 같은 I/O 중심의 작업에 대해 논블로킹 방식을 사용하는 것이 더 효율적일 수 있다.
 * 이를 위해 Spring WebFlux와 같은 논블로킹 프레임워크를 사용할 수 있다.
 * 이런 프레임워크는 I/O 작업이 완료될 때까지 기다리는 대신,
 * 작업이 준비될 때 알림을 받아 작업을 처리하는 방식을 사용한다.
 * 이는 리소스 사용을 최적화하고, 동시성을 개선하는 데 도움이 된다.
 *
 * <참고>
 * @Async 를 사용하면, 원래의 호출 스레드는 비동기 작업 스레드에 작업을 위임하고 즉시 반환된다.
 * 이렇게 호출 스레드가 메서드의 완료를 기다리지 않고 "즉시 반환되는 부분"은 논블로킹 방식과 일치한다.
 *
 * 하지만 @Async로 처리하는 비동기 작업 스레드가 실제로 I/O 작업을 수행하는 방식은 블로킹 될 수 있다.
 * 예를 들어, @Async 어노테이션이 붙은 메서드 내에서 RestTemplate 같은 블로킹 I/O 라이브러리를 사용하여
 * 외부 API를 호출하는 경우, 해당 I/O 작업이 완료될 때까지 비동기 작업 스레드는 블로킹된다.
 *
 * 따라서, @Async를 사용하는 경우 호출 스레드는 비동기적으로 동작하지만,
 * 실제 작업을 수행하는 비동기 작업 스레드는 I/O 작업이 블로킹되는 방식으로 동작할 수 있다.
 * 이 때문에, "완전한 논블로킹" 동작을 원하는 경우에는 I/O 작업 또한 논블로킹 방식으로 처리하는 것이 중요하다.
 * 이런 작업을 수행하기 위해서는 Spring WebFlux와 같은 논블로킹 I/O를 지원하는 라이브러리를 사용하는 것이 필요하다.
 *
 * <참고>
 * 본래의 호출 스레드(톰캣 워커 스레드)와 비동기 작업 스레드 사이에서는 논블로킹 방식이 적용되고 있다.
 * 호출 스레드는 비동기 작업 스레드에게 작업을 위임하고 즉시 반환되므로, 호출 스레드 입장에서 보면 논블로킹이다.
 *
 * 그러나, 여기서 "블로킹"과 "논블로킹"에 대한 논의를 넓혀서 볼 때,
 * 이는 일반적으로 I/O 작업에 대해 적용되는 개념이다.
 * 즉, 네트워크 요청과 같은 I/O 작업이 발생할 때,
 * 해당 작업을 수행하는 스레드가 작업이 완료될 때까지 기다리느냐(블로킹),
 * 아니면 작업의 완료를 기다리지 않고 즉시 반환하느냐(논블로킹)에 대한 차이이다.
 *
 * 따라서, 전체 시스템의 동작을 논블로킹 방식으로 만들기 위해서는,
 * 비동기 작업 스레드가 위임하는 I/O 작업 또한 논블로킹 방식으로 동작해야 한다.
 * 이를 위해 Spring WebFlux와 같은 논블로킹 I/O를 지원하는 라이브러리를 사용하게 된다.
 */
@FeignClient(name = "ExchangeRateFeign", url = "https://open.er-api.com/v6")
interface MyFeignClient {

    @GetMapping("/latest")
    ResponseExchangeRates getLatest(); //파라미터에 @RequestHeader, @RequestParam, @PathVariable 등을 사용할 수 있다.
    //Map<String, Object> 로 리턴 받아도 됨. 대신 필드명을 알아야하겠지?

    /**
     * OpenFeign 은 요청 인터페이스에 리턴 타입으로 CompletableFuture 가 지원되지 않는다..
     * 즉, 메서드를 호출한 스레드로 동기, 블로킹 방식으로 외부 api 요청/응답 처리가 이루어진다.
     */
    @GetMapping("/latest")
    Map<String, Object> getLatest2();
    //보일러플레이트 코드를 없애고 기능 위주의 코드 가독성을 위해 Dto 객체는 사용하지 않겠다.
}

/**
 * OpenFeign 자체는 스레드 풀을 관리하지 않는다.
 * OpenFeign 은 단순히 HTTP 요청을 생성하고, 처리하고, 네트워크로 전송하는 역할을 한다.
 *
 * 그래서.. OpenFeign 자체는 비동기 API 를 제공하지 않으므로,
 * OpenFeign 을 비동기적으로 호출하려면 별도의 비동기 메커니즘이 필요하다.
 * 여기서 Spring 의 @Async 가 그 역할을 해줄수있다.
 * @Async 가 붙은 메서드는 호출 시점에 Spring 이 별도의 스레드 풀에서 실행하도록 스케줄링하게 된다.
 *
 * 따라서, OpenFeign 을 @Async 와 함께 사용하게 되면,
 * 실질적으로 두 가지 유형의 스레드 풀이 관여하게 된다.
 * 하나는 Spring 의 @Async 에 의해 관리되는 스레드 풀로, 비즈니스 로직을 비동기적으로 실행하는 데 사용된다.
 * 다른 하나는 OpenFeign 이 내부적으로 사용하는 HTTP 클라이언트 라이브러리가 관리하는 I/O 스레드 풀로,
 * 네트워크 I/O를 처리하는 데 사용된다.
 *
 * 이 두 가지 스레드 풀은 별도로 동작하며, 각각 다른 책임을 가진다.
 * 하지만 비동기 처리에 관련된 리소스 관리와 성능 최적화를 위해서는 두 스레드 풀 모두 적절히 설정하고 관리하는 것이 중요하다.
 *
 * <참고>
 * 네트워크 요청과 응답의 처리는 I/O(입출력) 작업이다.
 * 이 I/O 작업은 많은 시간이 걸릴 수 있기 때문에, 주 스레드에서 직접 수행하게 되면 주 스레드가 차단되어 다른 작업을 진행하지 못하게 된다.
 * 이런 문제를 방지하기 위해 일반적으로 별도의 I/O 스레드를 활용하여 네트워크 I/O 작업을 처리한다.
 *
 * OpenFeign은 HTTP 요청과 응답을 처리하는 라이브러리인데, 내부적으로는 HTTP 클라이언트 라이브러리를 사용한다.
 * 이 HTTP 클라이언트 라이브러리는 네트워크 통신과 관련된 I/O 작업을 처리하는 역할을 한다.
 *
 * <참고>
 * I/O 스레드는 블로킹과 논블로킹 두 가지 방식 모두 가능하다.
 *
 * 블로킹 I/O는 요청을 보낸 후 응답이 올 때까지 해당 스레드가 차단(대기 상태)되는 방식이다.
 * 따라서 I/O 작업이 끝날 때까지 스레드가 다른 작업을 수행할 수 없게 된다.
 *
 * 논블로킹 I/O는 요청을 보낸 후 응답을 기다리지 않고 바로 반환하는 방식이다.
 * 따라서 I/O 작업이 진행되는 동안에도 스레드는 다른 작업을 계속 수행할 수 있다.
 *
 * HTTP 클라이언트 라이브러리에서 사용하는 I/O 스레드가 블로킹인지 논블로킹인지는 해당 라이브러리의 구현에 따라 다르다.
 * 일부 라이브러리는 블로킹 I/O를, 다른 일부 라이브러리는 논블로킹 I/O를 사용할 수 있다.
 *
 * 그러나 OpenFeign에서 내부적으로 사용하는 HTTP 클라이언트 라이브러리는 기본적으로 블로킹 I/O 방식을 사용한다.
 * 그래서 요청이 수행되는 동안에는 해당 I/O 스레드가 차단된다.
 * 이는 Spring WebFlux와 같은 논블로킹 I/O 방식과는 차이가 있다.
 */
